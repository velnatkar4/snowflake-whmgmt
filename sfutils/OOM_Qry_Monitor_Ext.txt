{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "823eb2b1",
   "metadata": {},
   "source": [
    "#### Snowflake Monitor: Track Out of Memory (OOM) Queries"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "e83e6a8d",
   "metadata": {},
   "source": [
    "##### Import Snowflake Connector package"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ab11e93f",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Import Snowflake Connector package\n",
    "import pandas as pd\n",
    "from datetime import date\n",
    "import time\n",
    "import os\n",
    "import json\n",
    "\n",
    "import snowflake.connector\n",
    "from snowflake.snowpark.session import Session\n",
    "from snowflake.snowpark.functions import col"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "6dac7a34",
   "metadata": {},
   "source": [
    "##### Get user credentials"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aaaf53dc",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Get user credentials\n",
    "with open(r\".\\secret\\creds.json\", 'r') as openfile:\n",
    "        creds = json.load(openfile)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "a5a71558",
   "metadata": {},
   "source": [
    "##### Create Snowpark Session"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f4dcb794-d9ff-40d1-969e-d51cdaa4dcdb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-09-17T21:50:21.849861Z",
     "iopub.status.busy": "2023-09-17T21:50:21.849551Z",
     "iopub.status.idle": "2023-09-17T21:50:21.853014Z",
     "shell.execute_reply": "2023-09-17T21:50:21.852444Z",
     "shell.execute_reply.started": "2023-09-17T21:50:21.849834Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "## Create Snowpark Session\n",
    "connection_parameters = {\n",
    "        \"account\": creds[\"account\"],    \n",
    "        \"user\" : creds[\"username\"],\n",
    "        \"password\" : creds[\"password\"],\n",
    "        \"database\" : creds[\"database\"],\n",
    "        \"schema\" : creds[\"schema\"],\n",
    "        \"warehouse\" : creds[\"warehouse\"],\n",
    "        \"role\" : creds[\"role\"]        \n",
    "    }\n",
    "    \n",
    "## Create a Snowpark session\n",
    "snpark_conn = Session.builder.configs(connection_parameters).getOrCreate()"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "6164db4d",
   "metadata": {},
   "source": [
    "##### Fetch long running queries that record disk spill"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f484217b",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Fetch long running queries that record disk spill\n",
    "qry_hst=\"CREATE OR REPLACE TEMPORARY TABLE TMP_OOM_QRY AS (SELECT QUERY_ID, \" \\\n",
    "    \"START_TIME::DATE AS START_DT,USER_NAME,((EXECUTION_TIME/(60000))) AS EXEC_TIME_MIN, \" \\\n",
    "    \"WAREHOUSE_SIZE, EXECUTION_STATUS AS EXEC_STATUS, \"\\\n",
    "    \"(CASE WHEN BYTES_SPILLED_TO_LOCAL_STORAGE > 0 THEN BYTES_SPILLED_TO_LOCAL_STORAGE/POWER(1024, 3) \" \\\n",
    "    \"ELSE BYTES_SPILLED_TO_LOCAL_STORAGE  END) AS GB_LOCAL_SPILL, \" \\\n",
    "    \"(CASE WHEN BYTES_SPILLED_TO_REMOTE_STORAGE > 0 THEN BYTES_SPILLED_TO_REMOTE_STORAGE/POWER(1024, 3) \" \\\n",
    "    \"ELSE BYTES_SPILLED_TO_REMOTE_STORAGE END) AS GB_REMOTE_SPILL, \" \\\n",
    "    \"(CASE WHEN BYTES_SENT_OVER_THE_NETWORK > 0 THEN BYTES_SENT_OVER_THE_NETWORK/POWER(1024, 3) \" \\\n",
    "    \"ELSE BYTES_SENT_OVER_THE_NETWORK END) AS GB_OVER_NETWORK \" \\\n",
    "    \"FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY A \" \\\n",
    "    \"WHERE ((EXECUTION_TIME/(60000))) > 60 \" \\\n",
    "    \"AND START_TIME::DATE >= CURRENT_DATE - 1 \" \\\n",
    "    \"AND (BYTES_SPILLED_TO_LOCAL_STORAGE > 0 OR BYTES_SPILLED_TO_REMOTE_STORAGE > 0) \" \\\n",
    "    \"AND BYTES_SENT_OVER_THE_NETWORK > 0) LIMIT 15\"\n",
    "\n",
    "snpark_conn.sql(qry_hst).collect()\n",
    "sf_df=snpark_conn.table(\"TMP_OOM_QRY\")\n",
    "p_df = sf_df.to_pandas()\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "a6cb8fb9",
   "metadata": {},
   "source": [
    "##### Create Temporary table to record OOM queries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f40e7ee4",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Row(status='Table TMP_OOM_QRY_CNT successfully created.')]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "## Create Temporary table to record OOM queries\n",
    "sql = \"CREATE OR REPLACE TEMPORARY TABLE TMP_OOM_QRY_CNT (\tQUERY_ID VARCHAR, OOM_CNT  NUMBER )\"\n",
    "snpark_conn.sql(sql).collect()"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "fc80047e",
   "metadata": {},
   "source": [
    "##### Evaluate Query profile to trace OOM queries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "efe18f84",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Evaluate Query profile to trace OOM queries\n",
    "for ind, row in p_df.iterrows():     \n",
    "    v_query_id = row['QUERY_ID']    \n",
    "    \n",
    "    ls_query_id = list(v_query_id.split(\" \"))    \n",
    "\n",
    "    sql=\"SELECT query_id, MAX(case when step_id > 2000 then 2 \" \\\n",
    "        \"when step_id > 1000 then 1 else 0 end) as OOM_COUNT \" \\\n",
    "        \"FROM table(get_query_operator_stats(?)) \" \\\n",
    "        \"WHERE step_id > 1000 \" \\\n",
    "        \"GROUP BY ALL\"\n",
    "    \n",
    "    sf_rs=snpark_conn.sql(sql, ls_query_id).collect()\n",
    "    p_df = pd.DataFrame(sf_rs)\n",
    "    if p_df.empty != True :\n",
    "        v_qry_id=p_df.loc[0,'QUERY_ID']\n",
    "        v_oom_cnt=p_df.loc[0,'OOM_COUNT']\n",
    "        sql = \"INSERT INTO TMP_OOM_QRY_CNT VALUES ('\" + v_qry_id + \"',\" + str(v_oom_cnt) + \")\"\n",
    "        snpark_conn.sql(sql).collect()\n",
    "    \n",
    "sf_df = snpark_conn.table(\"TMP_OOM_QRY_CNT\")\n",
    "sf_df.show()\n",
    "    "
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "id": "c623ab77",
   "metadata": {},
   "source": [
    "##### Final Report: Queries metrics with OOM count"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cad52a88",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Final Report: Queries metrics with OOM count\n",
    "df_qry = snpark_conn.table(\"TMP_OOM_QRY\").select(col(\"QUERY_ID\"),col(\"USER_NAME\"),col(\"START_DT\"),col(\"WAREHOUSE_SIZE\"),col(\"EXEC_TIME_MIN\"),col(\"GB_LOCAL_SPILL\"),col(\"GB_REMOTE_SPILL\"),col(\"GB_OVER_NETWORK\"))\n",
    "df_oom = snpark_conn.table(\"TMP_OOM_QRY_CNT\").select(col(\"QUERY_ID\"),col(\"OOM_CNT\"))\n",
    "\n",
    "df_oom_qrys = df_qry.join(df_oom, df_qry.col(\"QUERY_ID\") == df_oom.col(\"QUERY_ID\")) \\\n",
    "        .select(df_qry[\"USER_NAME\"].as_(\"USER_NAME\"),\n",
    "                df_qry[\"START_DT\"].as_(\"RUN_DT\"),\n",
    "                df_qry[\"WAREHOUSE_SIZE\"].as_(\"WAREHOUSE_SIZE\"),\n",
    "                df_oom[\"OOM_CNT\"].as_(\"OOM_CNT\"),\n",
    "                df_qry[\"QUERY_ID\"].as_(\"QUERY_ID\"),\n",
    "                df_qry[\"EXEC_TIME_MIN\"].as_(\"EXEC_TIME_MIN\"),\n",
    "                df_qry[\"GB_LOCAL_SPILL\"].as_(\"GB_LOCAL_SPILL\"),                \n",
    "                df_qry[\"GB_REMOTE_SPILL\"].as_(\"GB_REMOTE_SPILL\"),\n",
    "                df_qry[\"GB_OVER_NETWORK\"].as_(\"GB_OVER_NETWORK\"))\n",
    "df_oom_qrys.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
